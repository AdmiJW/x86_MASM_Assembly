
TITLE Exercise 7.1 - Extended Addition Procedure

;	Modify the Extended_Add procedure in Section 7.5.2 to add two 256-bit (32-byte) integers
;
;	Example Test Case:
;	
;	A: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
;	B: 100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010
;	RES: 10100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001010010010100100101001001001
;	   (in hex): 14a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a4a49
;
;	The program works with extended integers where the integers are stored in DWORD, reversed order in 8 bit chunks
;	because the addition will work from left to right.
INCLUDE Irvine32.inc

.data 

	OP_A DWORD 11111111111111111111111111111111b, 11111111111111111111111111111111b, 11111111111111111111111111111111b, 11111111111111111111111111111111b, 11111111111111111111111111111111b, 11111111111111111111111111111111b, 11111111111111111111111111111111b, 11111111111111111111111111111111b 
	OP_B DWORD 01001010010010100100101001001010b, 01001010010010100100101001001010b, 01001010010010100100101001001010b, 01001010010010100100101001001010b, 01001010010010100100101001001010b, 01001010010010100100101001001010b, 01001010010010100100101001001010b, 01001010010010100100101001001010b
	RES DWORD 9 DUP(0)

.code

;--------------------------------------------------------
;Calculates the sum of two extended integers that are
;stored as an array of doublewords 256 bits (32 bytes).
;Receives: ESI and EDI point to the two integers,
;EBX points to a variable that will hold the sum,
;--------------------------------------------------------
exercise7_1 PROC
	MOV ESI, OFFSET OP_A
	MOV EDI, OFFSET OP_B
	MOV EBX, OFFSET RES
	MOV ECX, 8					;We have 32 DWORDS to add

	PUSHAD						;Preserve the general purpose registers
	CLC							;Clear the carry flag

Summing_Loop: 
	MOV EAX, [ESI]
	ADC EAX, [EDI]
	PUSHFD						;Store the EFLAGS Register to stack since we need to perform addition in addresses
	
	MOV [EBX] ,EAX				;Store Addition result in EBX - Address to store result
	ADD ESI,4
	ADD EDI,4
	ADD EBX,4

	POPFD
	LOOP Summing_Loop

	ADC DWORD PTR [EBX], 0		;Final carry need to be added as well

	;	Print Result
	MOV ESI, OFFSET RES
	MOV ECX, 9
	MOV EBX, 4
	CALL DumpMem
	
	POPAD
	RET
exercise7_1 ENDP
END